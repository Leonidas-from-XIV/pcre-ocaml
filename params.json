{
  "name": "Pcre-ocaml",
  "tagline": "OCaml bindings to PCRE (Perl Compatibility Regular Expressions)",
  "body": "PCRE-OCaml - Perl Compatibility Regular Expressions for OCaml\r\n=============================================================\r\n\r\n---------------------------------------------------------------------------\r\n\r\nWhat is PCRE-OCaml?\r\n-------------------\r\n\r\nThis [OCaml](http://www.ocaml.org)-library interfaces the C-library\r\n[PCRE](http://www.pcre.org) (Perl-compatibility Regular Expressions).  It can\r\nbe used for matching regular expressions which are written in \"PERL\"-style.\r\n\r\n### Features\r\n\r\nPCRE-OCaml offers the following functionality for operating on strings:\r\n\r\n  * Searching for patterns\r\n  * Extracting subpatterns\r\n  * Splitting strings according to patterns\r\n  * Pattern substitution\r\n\r\nOther reasons to use PCRE-OCaml:\r\n\r\n  * The PCRE-library by Philip Hazel has been under development for many\r\n    years and is fairly advanced and stable.  It implements just about all\r\n    of the functionality that can be found in PERL regular expressions.\r\n    The higher-level functions written in OCaml (split, replace, etc.),\r\n    too, are compatible with the corresponding PERL-functions to the extent\r\n    that OCaml allows.  Most people find the syntax of PERL-style regular\r\n    expressions more straightforward and powerful than the Emacs-style regular\r\n    expressions used in the `Str`-module in the standard OCaml distribution.\r\n\r\n  * PCRE-OCaml is reentrant and thus thread-safe, which is not the case\r\n    for the `Str`-module in the OCaml standard library.  Using reentrant\r\n    libraries also means more convenience for programmers.  They do not\r\n    have to reason about states in which the library might be in.\r\n\r\n  * The high-level functions for replacement and substitution, which are all\r\n    implemented in OCaml, are much faster than the ones in the `Str`-module.\r\n    In fact, when compiled to native code, they even seem to be significantly\r\n    faster than those found in PERL (PERL is written in C).\r\n\r\n  * You can rely on the data returned being unique.  In other terms: if\r\n    the result of a function is a string, you can safely use destructive\r\n    updates on it without having to fear side effects.\r\n\r\n  * The interface to the library makes use of labels and default arguments\r\n    to give you a high degree of programming comfort.\r\n\r\n### Usage\r\n\r\nThe API-documentation which is built and installed with PCRE-OCaml explains all\r\nfunctions, most of which are fairly straightforward to understand, in detail.\r\nIt can also be found [online](http://mmottl.github.io/pcre-ocaml/api).\r\n\r\nA general concept the user may need to understand is that most functions\r\nallow for two different kinds of flags:\r\n\r\n  1. \"Convenience\"-flags that make for readable and concise code, but which\r\n     need to be translated to an internal representation on each call.\r\n     Example:\r\n\r\n     ```ocaml\r\n     let rex = regexp ~flags:[`ANCHORED; `CASELESS] \"some pattern\" in\r\n     (* ... *)\r\n     ```\r\n\r\n     This makes it easy to pass flags on the fly.  They will be translated to\r\n     the internal format automatically.  However, if this happens to be in a\r\n     loop, this translation will occur on each iteration.  If you really need\r\n     to save as much performance as possible, you should use the next approach.\r\n\r\n  2. \"Internal\" flags that need to be defined and translated from\r\n     \"convenience\"-flags before function calls, but which allow for optimum\r\n     performance in loops.  Example:\r\n\r\n     ```ocaml\r\n     let iflags = cflags [`ANCHORED; `CASELESS] in\r\n     for i = 1 to 1000 do\r\n       let rex = regexp ~iflags \"some pattern constructed at runtime\" in\r\n       (* ... *)\r\n     done\r\n     ```\r\n\r\n      Factoring out the translation of flags for regular expressions may\r\n      save some cycles, but don't expect too much.  You can save more CPU\r\n      time when lifting the creation of regular expressions out of loops.\r\n      Example for what not to do:\r\n\r\n      ```ocaml\r\n      for i = 1 to 1000 do\r\n        let chunks = split ~pat:\"[ \\t]+\" \"foo bar\" in\r\n        (* ... *)\r\n      done\r\n      ```\r\n\r\n      Better:\r\n\r\n      ```ocaml\r\n      let rex = regexp \"[ \\t]+\" in\r\n      for i = 1 to 1000 do\r\n        let chunks = split ~rex \"foo bar\" in\r\n        (* ... *)\r\n      done\r\n      ```\r\n\r\nThe provided functions use optional arguments with intuitive defaults.\r\nFor example, the `split`-function will assume whitespace as pattern.\r\n\r\nTake a look at the interface file `pcre.mli` to see which ways exists to pass\r\nparameters and to learn about the defaults.  The `examples`-directory contains\r\na few example applications demonstrating the functionality of PCRE-OCaml.\r\n\r\n---------------------------------------------------------------------------\r\n\r\nContact Information and Contributing\r\n------------------------------------\r\n\r\nIn the case of bugs, feature requests, contributions and similar, you can\r\ncontact me here: <markus.mottl@gmail.com>\r\n\r\nUp-to-date information should be available at:\r\n<http://mmottl.github.io/pcre-ocaml>\r\n\r\nEnjoy!\r\n\r\nMarkus Mottl on July 10, 2012\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}