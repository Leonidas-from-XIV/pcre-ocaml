<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Pcre" rel="Chapter" href="Pcre.html"><link title="Exceptions" rel="Section" href="#6_Exceptions">
<link title="Compilation and runtime flags and their conversion functions" rel="Section" href="#6_Compilationandruntimeflagsandtheirconversionfunctions">
<link title="Information on the PCRE-configuration (build-time options)" rel="Section" href="#6_InformationonthePCREconfigurationbuildtimeoptions">
<link title="Information on patterns" rel="Section" href="#6_Informationonpatterns">
<link title="Compilation of patterns" rel="Section" href="#6_Compilationofpatterns">
<link title="Subpattern extraction" rel="Section" href="#6_Subpatternextraction">
<link title="Callouts" rel="Section" href="#6_Callouts">
<link title="Matching of patterns and subpattern extraction" rel="Section" href="#6_Matchingofpatternsandsubpatternextraction">
<link title="String substitution" rel="Section" href="#6_Stringsubstitution">
<link title="Splitting" rel="Section" href="#6_Splitting">
<link title="Additional convenience functions" rel="Section" href="#6_Additionalconveniencefunctions">
<link title="UNSAFE STUFF - USE WITH CAUTION!" rel="Section" href="#6_UNSAFESTUFFUSEWITHCAUTION">
<title>Pcre</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;</div>
<h1>Module <a href="type_Pcre.html">Pcre</a></h1>

<pre><span class="keyword">module</span> Pcre: <code class="code">sig</code> <a href="Pcre.html">..</a> <code class="code">end</code></pre><div class="info module top">
Perl Compatibility Regular Expressions<br>
</div>
<hr width="100%">
<br>
<h6 id="6_Exceptions">Exceptions</h6><br>

<pre><code><span id="TYPEerror"><span class="keyword">type</span> <code class="type"></code>error</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTerror.Partial"><span class="constructor">Partial</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
String only matched the pattern partially<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTerror.BadPartial"><span class="constructor">BadPartial</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Pattern contains items that cannot be used together
                    with partial matching.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTerror.BadPattern"><span class="constructor">BadPattern</span></span> <span class="keyword">of</span> <code class="type">string * int</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<code class="code">BadPattern (msg, pos)</code> regular
                                    expression is malformed.  The reason
                                    is in <code class="code">msg</code>, the position of the
                                    error in the pattern in <code class="code">pos</code>.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTerror.BadUTF8"><span class="constructor">BadUTF8</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
UTF8 string being matched is invalid<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTerror.BadUTF8Offset"><span class="constructor">BadUTF8Offset</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Gets raised when a UTF8 string being matched with
                       offset is invalid.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTerror.MatchLimit"><span class="constructor">MatchLimit</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Maximum allowed number of match attempts with
                    backtracking or recursion is reached during matching.
                    ALL FUNCTIONS CALLING THE MATCHING ENGINE MAY RAISE
                    IT!!!<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTerror.RecursionLimit"><span class="constructor">RecursionLimit</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTerror.InternalError"><span class="constructor">InternalError</span></span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<code class="code">InternalError msg</code> C-library exhibits unknown/undefined
          behaviour.  The reason is in <code class="code">msg</code>.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>



<pre><span id="EXCEPTIONError"><span class="keyword">exception</span> Error</span> <span class="keyword">of</span> <code class="type"><a href="Pcre.html#TYPEerror">error</a></code></pre>
<div class="info ">
Exception indicating PCRE errors.<br>
</div>

<pre><span id="EXCEPTIONBacktrack"><span class="keyword">exception</span> Backtrack</span></pre>
<div class="info ">
<code class="code">Backtrack</code> used in callout functions to force backtracking.<br>
</div>

<pre><span id="EXCEPTIONRegexp_or"><span class="keyword">exception</span> Regexp_or</span> <span class="keyword">of</span> <code class="type">string * <a href="Pcre.html#TYPEerror">error</a></code></pre>
<div class="info ">
<code class="code">Regexp_or (pat, error)</code> gets raised for sub-pattern <code class="code">pat</code> by <code class="code">regexp_or</code>
    if it failed to compile.<br>
</div>
<br>
<h6 id="6_Compilationandruntimeflagsandtheirconversionfunctions">Compilation and runtime flags and their conversion functions</h6><br>

<pre><span id="TYPEicflag"><span class="keyword">type</span> <code class="type"></code>icflag</span> </pre>
<div class="info ">
Internal representation of compilation flags<br>
</div>


<pre><span id="TYPEirflag"><span class="keyword">type</span> <code class="type"></code>irflag</span> </pre>
<div class="info ">
Internal representation of runtime flags<br>
</div>


<pre><span id="TYPEcflag"><span class="keyword">type</span> <code class="type"></code>cflag</span> = <code class="type">[ `ANCHORED<br>       | `AUTO_CALLOUT<br>       | `CASELESS<br>       | `DOLLAR_ENDONLY<br>       | `DOTALL<br>       | `EXTENDED<br>       | `EXTRA<br>       | `FIRSTLINE<br>       | `MULTILINE<br>       | `NO_AUTO_CAPTURE<br>       | `NO_UTF8_CHECK<br>       | `UNGREEDY<br>       | `UTF8 ]</code> </pre>
<div class="info ">
Compilation flags<br>
</div>


<pre><span id="VALcflags"><span class="keyword">val</span> cflags</span> : <code class="type"><a href="Pcre.html#TYPEcflag">cflag</a> list -> <a href="Pcre.html#TYPEicflag">icflag</a></code></pre><div class="info ">
<code class="code">cflags cflag_list</code> converts a list of compilation flags to
    their internal representation.<br>
</div>

<pre><span id="VALcflag_list"><span class="keyword">val</span> cflag_list</span> : <code class="type"><a href="Pcre.html#TYPEicflag">icflag</a> -> <a href="Pcre.html#TYPEcflag">cflag</a> list</code></pre><div class="info ">
<code class="code">cflag_list cflags</code> converts internal representation of
    compilation flags to a list.<br>
</div>

<pre><span id="TYPErflag"><span class="keyword">type</span> <code class="type"></code>rflag</span> = <code class="type">[ `ANCHORED | `NOTBOL | `NOTEMPTY | `NOTEOL | `PARTIAL ]</code> </pre>
<div class="info ">
Runtime flags<br>
</div>


<pre><span id="VALrflags"><span class="keyword">val</span> rflags</span> : <code class="type"><a href="Pcre.html#TYPErflag">rflag</a> list -> <a href="Pcre.html#TYPEirflag">irflag</a></code></pre><div class="info ">
<code class="code">rflags rflag_list</code> converts a list of runtime flags to
    their internal representation.<br>
</div>

<pre><span id="VALrflag_list"><span class="keyword">val</span> rflag_list</span> : <code class="type"><a href="Pcre.html#TYPEirflag">irflag</a> -> <a href="Pcre.html#TYPErflag">rflag</a> list</code></pre><div class="info ">
<code class="code">rflag_list rflags</code> converts internal representation of
    runtime flags to a list.<br>
</div>
<br>
<h6 id="6_InformationonthePCREconfigurationbuildtimeoptions">Information on the PCRE-configuration (build-time options)</h6><br>

<pre><span id="VALversion"><span class="keyword">val</span> version</span> : <code class="type">string</code></pre><div class="info ">
Version information
<p>
Version of the PCRE-C-library<br>
</div>

<pre><span id="VALconfig_utf8"><span class="keyword">val</span> config_utf8</span> : <code class="type">bool</code></pre><div class="info ">
Indicates whether UTF8-support is enabled<br>
</div>

<pre><span id="VALconfig_newline"><span class="keyword">val</span> config_newline</span> : <code class="type">char</code></pre><div class="info ">
Character used as newline<br>
</div>

<pre><span id="VALconfig_link_size"><span class="keyword">val</span> config_link_size</span> : <code class="type">int</code></pre><div class="info ">
Number of bytes used for internal linkage of regular expressions<br>
</div>

<pre><span id="VALconfig_match_limit"><span class="keyword">val</span> config_match_limit</span> : <code class="type">int</code></pre><div class="info ">
Default limit for calls to internal matching function<br>
</div>

<pre><span id="VALconfig_match_limit_recursion"><span class="keyword">val</span> config_match_limit_recursion</span> : <code class="type">int</code></pre><div class="info ">
Default limit recursion for calls to internal matching function<br>
</div>

<pre><span id="VALconfig_stackrecurse"><span class="keyword">val</span> config_stackrecurse</span> : <code class="type">bool</code></pre><div class="info ">
Indicates use of stack recursion in matching function<br>
</div>
<br>
<h6 id="6_Informationonpatterns">Information on patterns</h6><br>

<pre><span id="TYPEfirstbyte_info"><span class="keyword">type</span> <code class="type"></code>firstbyte_info</span> = <code class="type">[ `ANCHORED | `Char of char | `Start_only ]</code> </pre>
<div class="info ">
Information on matching of "first chars" in patterns<br>
</div>


<pre><span id="TYPEstudy_stat"><span class="keyword">type</span> <code class="type"></code>study_stat</span> = <code class="type">[ `Not_studied | `Optimal | `Studied ]</code> </pre>
<div class="info ">
Information on the study status of patterns<br>
</div>


<pre><span id="TYPEregexp"><span class="keyword">type</span> <code class="type"></code>regexp</span> </pre>
<div class="info ">
Compiled regular expressions<br>
</div>


<pre><span id="VALoptions"><span class="keyword">val</span> options</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> <a href="Pcre.html#TYPEicflag">icflag</a></code></pre><div class="info ">
<code class="code">options regexp</code><br>
<b>Returns</b> compilation flags of <code class="code">regexp</code>.<br>
</div>

<pre><span id="VALsize"><span class="keyword">val</span> size</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> int</code></pre><div class="info ">
<code class="code">size regexp</code><br>
<b>Returns</b> memory size of <code class="code">regexp</code>.<br>
</div>

<pre><span id="VALstudysize"><span class="keyword">val</span> studysize</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> int</code></pre><div class="info ">
<code class="code">studysize regexp</code><br>
<b>Returns</b> memory size of study information of <code class="code">regexp</code>.<br>
</div>

<pre><span id="VALcapturecount"><span class="keyword">val</span> capturecount</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> int</code></pre><div class="info ">
<code class="code">capturecount regexp</code><br>
<b>Returns</b> number of capturing subpatterns in
    <code class="code">regexp</code>.<br>
</div>

<pre><span id="VALbackrefmax"><span class="keyword">val</span> backrefmax</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> int</code></pre><div class="info ">
<code class="code">backrefmax regexp</code><br>
<b>Returns</b> number of highest backreference in <code class="code">regexp</code>.<br>
</div>

<pre><span id="VALnamecount"><span class="keyword">val</span> namecount</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> int</code></pre><div class="info ">
<code class="code">namecount regexp</code><br>
<b>Returns</b> number of named subpatterns in <code class="code">regexp</code>.<br>
</div>

<pre><span id="VALnames"><span class="keyword">val</span> names</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> string array</code></pre><div class="info ">
<code class="code">names regex</code><br>
<b>Returns</b> array of names of named substrings in <code class="code">regexp</code>.<br>
</div>

<pre><span id="VALnameentrysize"><span class="keyword">val</span> nameentrysize</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> int</code></pre><div class="info ">
<code class="code">nameentrysize regexp</code><br>
<b>Returns</b> size of longest name of named
    subpatterns in <code class="code">regexp</code> + 3.<br>
</div>

<pre><span id="VALfirstbyte"><span class="keyword">val</span> firstbyte</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> <a href="Pcre.html#TYPEfirstbyte_info">firstbyte_info</a></code></pre><div class="info ">
<code class="code">firstbyte regexp</code><br>
<b>Returns</b> firstbyte info on <code class="code">regexp</code>.<br>
</div>

<pre><span id="VALfirsttable"><span class="keyword">val</span> firsttable</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> string option</code></pre><div class="info ">
<code class="code">firsttable regexp</code><br>
<b>Returns</b> some 256-bit (32-byte) fixed set table in
    form of a string for <code class="code">regexp</code> if available, <code class="code">None</code> otherwise.<br>
</div>

<pre><span id="VALlastliteral"><span class="keyword">val</span> lastliteral</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> char option</code></pre><div class="info ">
<code class="code">lastliteral regexp</code><br>
<b>Returns</b> some last matching character of <code class="code">regexp</code>
    if available, <code class="code">None</code> otherwise.<br>
</div>

<pre><span id="VALstudy_stat"><span class="keyword">val</span> study_stat</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> <a href="Pcre.html#TYPEstudy_stat">study_stat</a></code></pre><div class="info ">
<code class="code">study_stat regexp</code><br>
<b>Returns</b> study status of <code class="code">regexp</code>.<br>
</div>

<pre><span id="VALget_stringnumber"><span class="keyword">val</span> get_stringnumber</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> string -> int</code></pre><div class="info ">
<code class="code">get_stringnumber rex name</code><br>
<b>Raises</b> <code>Invalid_arg</code> if there is no such named substring.<br>
<b>Returns</b> the index of the named substring
    <code class="code">name</code> in regular expression <code class="code">rex</code>. This index can then be used with
    <code class="code">get_substring</code>.<br>
</div>

<pre><span id="VALget_match_limit"><span class="keyword">val</span> get_match_limit</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> int option</code></pre><div class="info ">
<code class="code">get_match_limit rex</code><br>
<b>Returns</b> some match limit of regular expression
    <code class="code">rex</code> or <code class="code">None</code>.<br>
</div>

<pre><span id="VALget_match_limit_recursion"><span class="keyword">val</span> get_match_limit_recursion</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> int option</code></pre><div class="info ">
<code class="code">get_match_limit_recursion rex</code><br>
<b>Returns</b> some recursion match limit
    of regular expression <code class="code">rex</code> or <code class="code">None</code>.<br>
</div>
<br>
<h6 id="6_Compilationofpatterns">Compilation of patterns</h6><br>

<pre><span id="TYPEchtables"><span class="keyword">type</span> <code class="type"></code>chtables</span> </pre>
<div class="info ">
Alternative set of char tables for pattern matching<br>
</div>


<pre><span id="VALmaketables"><span class="keyword">val</span> maketables</span> : <code class="type">unit -> <a href="Pcre.html#TYPEchtables">chtables</a></code></pre><div class="info ">
Generates new set of char tables for the current locale.<br>
</div>

<pre><span id="VALregexp"><span class="keyword">val</span> regexp</span> : <code class="type">?study:bool -><br>       ?limit:int -><br>       ?limit_recursion:int -><br>       ?iflags:<a href="Pcre.html#TYPEicflag">icflag</a> -><br>       ?flags:<a href="Pcre.html#TYPEcflag">cflag</a> list -> ?chtables:<a href="Pcre.html#TYPEchtables">chtables</a> -> string -> <a href="Pcre.html#TYPEregexp">regexp</a></code></pre><div class="info ">
<code class="code">regexp ?study ?limit ?limit_recursion ?iflags ?flags ?chtables pattern</code>
    compiles <code class="code">pattern</code> with <code class="code">flags</code> when given, with <code class="code">iflags</code> otherwise, and
    with char tables <code class="code">chtables</code>. If <code class="code">study</code> is true, then the resulting regular
    expression will be studied. If <code class="code">limit</code> is specified, this sets a limit to
    the amount of recursion and backtracking (only lower than the builtin
    default!). If this limit is exceeded, <code class="code">MatchLimit</code> will be raised during
    matching.<br>
<b>Returns</b> the regular expression.
<p>

    For detailed documentation on how you can specify PERL-style regular
    expressions (= patterns), please consult the PCRE-documentation
    ("man pcrepattern") or PERL-manuals.<br>
<b>See also</b> <a href="http://www.perl.com">www.perl.com</a><br>
</div>
<div class="param_info"><code class="code">study</code> : default = true</div>
<div class="param_info"><code class="code">limit</code> : default = no extra limit other than default</div>
<div class="param_info"><code class="code">limit_recursion</code> : default = no extra limit_recursion other than default</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">chtables</code> : default = builtin char tables</div>

<pre><span id="VALregexp_or"><span class="keyword">val</span> regexp_or</span> : <code class="type">?study:bool -><br>       ?limit:int -><br>       ?limit_recursion:int -><br>       ?iflags:<a href="Pcre.html#TYPEicflag">icflag</a> -><br>       ?flags:<a href="Pcre.html#TYPEcflag">cflag</a> list -><br>       ?chtables:<a href="Pcre.html#TYPEchtables">chtables</a> -> string list -> <a href="Pcre.html#TYPEregexp">regexp</a></code></pre><div class="info ">
<code class="code">regexp_or ?study ?limit ?limit_recursion ?iflags ?flags ?chtables patterns</code>
    like <a href="Pcre.html#VALregexp"><code class="code">Pcre.regexp</code></a>, but combines <code class="code">patterns</code> as alternatives (or-patterns) into
    one regular expression.<br>
</div>

<pre><span id="VALquote"><span class="keyword">val</span> quote</span> : <code class="type">string -> string</code></pre><div class="info ">
<code class="code">quote str</code><br>
<b>Returns</b> the quoted string of <code class="code">str</code>.<br>
</div>
<br>
<h6 id="6_Subpatternextraction">Subpattern extraction</h6><br>

<pre><span id="TYPEsubstrings"><span class="keyword">type</span> <code class="type"></code>substrings</span> </pre>
<div class="info ">
Information on substrings after pattern matching<br>
</div>


<pre><span id="VALget_subject"><span class="keyword">val</span> get_subject</span> : <code class="type"><a href="Pcre.html#TYPEsubstrings">substrings</a> -> string</code></pre><div class="info ">
<code class="code">get_subject substrings</code><br>
<b>Returns</b> the subject string of <code class="code">substrings</code>.<br>
</div>

<pre><span id="VALnum_of_subs"><span class="keyword">val</span> num_of_subs</span> : <code class="type"><a href="Pcre.html#TYPEsubstrings">substrings</a> -> int</code></pre><div class="info ">
<code class="code">num_of_subs substrings</code><br>
<b>Returns</b> number of strings in <code class="code">substrings</code>
    (whole match inclusive).<br>
</div>

<pre><span id="VALget_substring"><span class="keyword">val</span> get_substring</span> : <code class="type"><a href="Pcre.html#TYPEsubstrings">substrings</a> -> int -> string</code></pre><div class="info ">
<code class="code">get_substring substrings n</code><br>
<b>Raises</b><ul><li><code>Invalid_argument</code> if <code class="code">n</code> is not in the range of the number of
    substrings.</li>
<li><code>Not_found</code> if the corresponding subpattern did not capture
           a substring.</li>
</ul>
<b>Returns</b> the <code class="code">n</code>th substring
    (0 is whole match) of <code class="code">substrings</code>.<br>
</div>

<pre><span id="VALget_substring_ofs"><span class="keyword">val</span> get_substring_ofs</span> : <code class="type"><a href="Pcre.html#TYPEsubstrings">substrings</a> -> int -> int * int</code></pre><div class="info ">
<code class="code">get_substring_ofs substrings n</code><br>
<b>Raises</b><ul><li><code>Invalid_argument</code> if <code class="code">n</code> is not in the range of the number
           of substrings.</li>
<li><code>Not_found</code> if the corresponding subpattern did not capture
           a substring.</li>
</ul>
<b>Returns</b> the offset tuple of the
    <code class="code">n</code>th substring of <code class="code">substrings</code> (0 is whole match).<br>
</div>

<pre><span id="VALget_substrings"><span class="keyword">val</span> get_substrings</span> : <code class="type">?full_match:bool -> <a href="Pcre.html#TYPEsubstrings">substrings</a> -> string array</code></pre><div class="info ">
<code class="code">get_substrings ?full_match substrings</code><br>
<b>Returns</b> the array of
    substrings in <code class="code">substrings</code>. It includes the full match at index 0
    when <code class="code">full_match</code> is <code class="code">true</code>, the captured substrings only when it
    is <code class="code">false</code>. If a subpattern did not capture a substring, the empty
    string is returned in the corresponding position instead.<br>
</div>
<div class="param_info"><code class="code">full_match</code> : default = true</div>

<pre><span id="VALget_opt_substrings"><span class="keyword">val</span> get_opt_substrings</span> : <code class="type">?full_match:bool -> <a href="Pcre.html#TYPEsubstrings">substrings</a> -> string option array</code></pre><div class="info ">
<code class="code">get_opt_substrings ?full_match substrings</code><br>
<b>Returns</b> the array of
    optional substrings in <code class="code">substrings</code>. It includes <code class="code">Some full_match_str</code>
    at index 0 when <code class="code">full_match</code> is <code class="code">true</code>, <code class="code">Some captured_substrings</code>
    only when it is <code class="code">false</code>. If a subpattern did not capture a substring,
    <code class="code">None</code> is returned in the corresponding position instead.<br>
</div>
<div class="param_info"><code class="code">full_match</code> : default = true</div>

<pre><span id="VALget_named_substring"><span class="keyword">val</span> get_named_substring</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> string -> <a href="Pcre.html#TYPEsubstrings">substrings</a> -> string</code></pre><div class="info ">
<code class="code">get_named_substring rex name substrings</code><br>
<b>Raises</b><ul><li><code>Invalid_argument</code> if there is no such named substring.</li>
<li><code>Not_found</code> if the corresponding subpattern did not capture
           a substring.</li>
</ul>
<b>Returns</b> the named substring
    <code class="code">name</code> in regular expression <code class="code">rex</code> and <code class="code">substrings</code>.<br>
</div>

<pre><span id="VALget_named_substring_ofs"><span class="keyword">val</span> get_named_substring_ofs</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> string -> <a href="Pcre.html#TYPEsubstrings">substrings</a> -> int * int</code></pre><div class="info ">
<code class="code">get_named_substring_ofs rex name substrings</code><br>
<b>Raises</b><ul><li><code>Invalid_argument</code> if there is no such named substring.</li>
<li><code>Not_found</code> if the corresponding subpattern did not capture
           a substring.</li>
</ul>
<b>Returns</b> the offset
    tuple of the named substring <code class="code">name</code> in regular expression <code class="code">rex</code> and
    <code class="code">substrings</code>.<br>
</div>
<br>
<h6 id="6_Callouts">Callouts</h6><br>

<pre><code><span id="TYPEcallout_data"><span class="keyword">type</span> <code class="type"></code>callout_data</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTcallout_data.callout_number">callout_number</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Callout number<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTcallout_data.substrings">substrings</span>&nbsp;: <code class="type"><a href="Pcre.html#TYPEsubstrings">substrings</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Substrings matched so far<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTcallout_data.start_match">start_match</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Subject start offset of current match attempt<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTcallout_data.current_position">current_position</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Subject offset of current match pointer<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTcallout_data.capture_top">capture_top</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Number of the highest captured substring so far<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTcallout_data.capture_last">capture_last</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Number of the most recently captured substring<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTcallout_data.pattern_position">pattern_position</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Offset of next match item in pattern string<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTcallout_data.next_item_length">next_item_length</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Length of next match item in pattern string<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}



<pre><span id="TYPEcallout"><span class="keyword">type</span> <code class="type"></code>callout</span> = <code class="type"><a href="Pcre.html#TYPEcallout_data">callout_data</a> -> unit</code> </pre>
<div class="info ">
Type of callout functions
<p>
Callouts are referred to in patterns as "(?Cn)" where "n" is a
    <code class="code">callout_number</code> ranging from 0 to 255.  Substrings captured so far
    are accessible as usual via <code class="code">substrings</code>.  You will have to consider
    <code class="code">capture_top</code> and <code class="code">capture_last</code> to know about the current state of
    valid substrings.
<p>

    By raising exception <code class="code">Backtrack</code> within a callout function, the user
    can force the pattern matching engine to backtrack to other possible
    solutions.  Other exceptions will terminate matching immediately
    and return control to OCaml.<br>
</div>

<br>
<h6 id="6_Matchingofpatternsandsubpatternextraction">Matching of patterns and subpattern extraction</h6><br>

<pre><span id="VALpcre_exec"><span class="keyword">val</span> pcre_exec</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -> ?pos:int -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> int array</code></pre><div class="info ">
<code class="code">pcre_exec ?iflags ?flags ?rex ?pat ?pos ?callout subj</code><br>
<b>Raises</b> <code>Not_found</code> if pattern does not match.<br>
<b>Returns</b> an
    array of offsets that describe the position of matched subpatterns in
    the string <code class="code">subj</code> starting at position <code class="code">pos</code> with pattern <code class="code">pat</code> when
    given, regular expression <code class="code">rex</code> otherwise. The array also contains
    additional workspace needed by the match engine. Uses <code class="code">flags</code> when
    given, the precompiled <code class="code">iflags</code> otherwise. Callouts are handled by
    <code class="code">callout</code>.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALexec"><span class="keyword">val</span> exec</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -> ?pos:int -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> <a href="Pcre.html#TYPEsubstrings">substrings</a></code></pre><div class="info ">
<code class="code">exec ?iflags ?flags ?rex ?pat ?pos ?callout subj</code><br>
<b>Raises</b> <code>Not_found</code> if pattern does not match.<br>
<b>Returns</b> substring
    information on string <code class="code">subj</code> starting at position <code class="code">pos</code> with pattern
    <code class="code">pat</code> when given, regular expression <code class="code">rex</code> otherwise. Uses <code class="code">flags</code>
    when given, the precompiled <code class="code">iflags</code> otherwise. Callouts are handled
    by <code class="code">callout</code>.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALexec_all"><span class="keyword">val</span> exec_all</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> <a href="Pcre.html#TYPEsubstrings">substrings</a> array</code></pre><div class="info ">
<code class="code">exec_all ?iflags ?flags ?rex ?pat ?pos ?callout subj</code><br>
<b>Raises</b> <code>Not_found</code> if pattern does not match.<br>
<b>Returns</b> an array of substring information of all matching substrings in
    string <code class="code">subj</code> starting at position <code class="code">pos</code> with pattern <code class="code">pat</code> when
    given, regular expression <code class="code">rex</code> otherwise. Uses <code class="code">flags</code> when given,
    the precompiled <code class="code">iflags</code> otherwise. Callouts are handled by <code class="code">callout</code>.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALnext_match"><span class="keyword">val</span> next_match</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> <a href="Pcre.html#TYPEsubstrings">substrings</a> -> <a href="Pcre.html#TYPEsubstrings">substrings</a></code></pre><div class="info ">
<code class="code">next_match ?iflags ?flags ?rex ?pat ?pos ?callout substrs</code><br>
<b>Raises</b><ul><li><code>Not_found</code> if pattern does not match.</li>
<li><code>Invalid_arg</code> if <code class="code">pos</code> let matching start outside of
           the subject string.</li>
</ul>
<b>Returns</b> substring information on the match that follows on the last
    match denoted by <code class="code">substrs</code>, jumping over <code class="code">pos</code> characters (also
    backwards!), using pattern <code class="code">pat</code> when given, regular expression
    <code class="code">rex</code> otherwise. Uses <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code>
    otherwise. Callouts are handled by <code class="code">callout</code>.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALextract"><span class="keyword">val</span> extract</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -><br>       ?full_match:bool -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> string array</code></pre><div class="info ">
<code class="code">extract ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code><br>
<b>Raises</b> <code>Not_found</code> if pattern does not match.<br>
<b>Returns</b> the array of substrings that match <code class="code">subj</code> starting at
    position <code class="code">pos</code>, using pattern <code class="code">pat</code> when given, regular expression
    <code class="code">rex</code> otherwise. Uses <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code>
    otherwise. It includes the full match at index 0 when <code class="code">full_match</code> is
    <code class="code">true</code>, the captured substrings only when it is <code class="code">false</code>. Callouts are
    handled by <code class="code">callout</code>.  If a subpattern did not capture a substring,
    the empty string is returned in the corresponding position instead.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">full_match</code> : default = true</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALextract_opt"><span class="keyword">val</span> extract_opt</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -><br>       ?full_match:bool -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> string option array</code></pre><div class="info ">
<code class="code">extract_opt ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code><br>
<b>Raises</b> <code>Not_found</code> if pattern does not match.<br>
<b>Returns</b> the array of optional substrings that match <code class="code">subj</code> starting
    at position <code class="code">pos</code>, using pattern <code class="code">pat</code> when given, regular expression
    <code class="code">rex</code> otherwise. Uses <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code>
    otherwise. It includes <code class="code">Some full_match_str</code> at index 0 when
    <code class="code">full_match</code> is <code class="code">true</code>, <code class="code">Some captured-substrings</code> only when it is
    <code class="code">false</code>. Callouts are handled by <code class="code">callout</code>.  If a subpattern did
    not capture a substring, <code class="code">None</code> is returned in the corresponding
    position instead.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">full_match</code> : default = true</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALextract_all"><span class="keyword">val</span> extract_all</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -><br>       ?full_match:bool -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> string array array</code></pre><div class="info ">
<code class="code">extract_all ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code><br>
<b>Raises</b> <code>Not_found</code> if pattern does not match.<br>
<b>Returns</b> an array of arrays of all matching substrings that match
    <code class="code">subj</code> starting at position <code class="code">pos</code>, using pattern <code class="code">pat</code> when given,
    regular expression <code class="code">rex</code> otherwise. Uses <code class="code">flags</code> when given, the
    precompiled <code class="code">iflags</code> otherwise. It includes the full match at index
    0 of the extracted string arrays when <code class="code">full_match</code> is <code class="code">true</code>, the
    captured substrings only when it is <code class="code">false</code>. Callouts are handled by
    <code class="code">callout</code>.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">full_match</code> : default = true</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALextract_all_opt"><span class="keyword">val</span> extract_all_opt</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -><br>       ?full_match:bool -><br>       ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> string option array array</code></pre><div class="info ">
<code class="code">extract_all_opt
      ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code><br>
<b>Raises</b> <code>Not_found</code> if pattern does not match.<br>
<b>Returns</b> an array of arrays of all optional matching substrings that
    match <code class="code">subj</code> starting at position <code class="code">pos</code>, using pattern <code class="code">pat</code> when
    given, regular expression <code class="code">rex</code> otherwise. Uses <code class="code">flags</code> when given,
    the precompiled <code class="code">iflags</code> otherwise. It includes <code class="code">Some full_match_str</code>
    at index 0 of the extracted string arrays when <code class="code">full_match</code> is <code class="code">true</code>,
    <code class="code">Some captured_substrings</code> only when it is <code class="code">false</code>. Callouts are
    handled by <code class="code">callout</code>.  If a subpattern did not capture a substring,
    <code class="code">None</code> is returned in the corresponding position instead.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">full_match</code> : default = true</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALpmatch"><span class="keyword">val</span> pmatch</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -> ?pos:int -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> bool</code></pre><div class="info ">
<code class="code">pmatch ?iflags ?flags ?rex ?pat ?pos ?callout subj</code><br>
<b>Returns</b> <code class="code">true</code>
    if <code class="code">subj</code> is matched by pattern <code class="code">pat</code> when given, regular expression
    <code class="code">rex</code> otherwise, starting at position <code class="code">pos</code>. Uses <code class="code">flags</code> when given,
    the precompiled <code class="code">iflags</code> otherwise. Callouts are handled by <code class="code">callout</code>.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>
<br>
<h6 id="6_Stringsubstitution">String substitution</h6><br>

<pre><span id="TYPEsubstitution"><span class="keyword">type</span> <code class="type"></code>substitution</span> </pre>
<div class="info ">
Information on substitution patterns<br>
</div>


<pre><span id="VALsubst"><span class="keyword">val</span> subst</span> : <code class="type">string -> <a href="Pcre.html#TYPEsubstitution">substitution</a></code></pre><div class="info ">
<code class="code">subst str</code> converts the string <code class="code">str</code> representing a
    substitution pattern to the internal representation
<p>

    The contents of the substitution string <code class="code">str</code> can be normal text
    mixed with any of the following (mostly as in PERL):
<p>
<ul>
<li><em>$[0-9]+</em>  - a "$" immediately followed by an arbitrary number.
                       "$0" stands for the name of the executable,
                       any other number for the n-th backreference.</li>
<li><em>$&amp;</em>         - the whole matched pattern</li>
<li><em>$`</em>         - the text before the match</li>
<li><em>$'</em>         - the text after the match</li>
<li><em>$+</em>         - the last group that matched</li>
<li><em>$$</em>         - a single "$"</li>
<li><em>$!</em>         - delimiter which does not appear in the substitution.
                       Can be used to part "$<code class="code">0-9</code>+" from an immediately
                       following other number.</li>
</ul>
<br>
</div>

<pre><span id="VALreplace"><span class="keyword">val</span> replace</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -><br>       ?itempl:<a href="Pcre.html#TYPEsubstitution">substitution</a> -><br>       ?templ:string -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> string</code></pre><div class="info ">
<code class="code">replace ?iflags ?flags ?rex ?pat ?pos ?itempl ?templ ?callout subj</code>
    replaces all substrings of <code class="code">subj</code> matching pattern <code class="code">pat</code> when given,
    regular expression <code class="code">rex</code> otherwise, starting at position <code class="code">pos</code> with
    the substitution string <code class="code">templ</code> when given, <code class="code">itempl</code> otherwise. Uses
    <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code> otherwise. Callouts
    are handled by <code class="code">callout</code>.<br>
<b>Raises</b> <code>Failure</code> if there are backreferences to nonexistent subpatterns.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">itempl</code> : default = empty string</div>
<div class="param_info"><code class="code">templ</code> : default = ignored</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALqreplace"><span class="keyword">val</span> qreplace</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -> ?templ:string -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> string</code></pre><div class="info ">
<code class="code">qreplace ?iflags ?flags ?rex ?pat ?pos ?templ ?callout subj</code>
    replaces all substrings of <code class="code">subj</code> matching pattern <code class="code">pat</code> when given,
    regular expression <code class="code">rex</code> otherwise, starting at position <code class="code">pos</code>
    with the string <code class="code">templ</code>. Uses <code class="code">flags</code> when given, the precompiled
    <code class="code">iflags</code> otherwise. Callouts are handled by <code class="code">callout</code>.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">templ</code> : default = ignored</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALsubstitute_substrings"><span class="keyword">val</span> substitute_substrings</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -><br>       ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -><br>       subst:(<a href="Pcre.html#TYPEsubstrings">substrings</a> -> string) -> string -> string</code></pre><div class="info ">
<code class="code">substitute_substrings ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code>
    replaces all substrings of <code class="code">subj</code> matching pattern <code class="code">pat</code> when given,
    regular expression <code class="code">rex</code> otherwise, starting at position <code class="code">pos</code>
    with the result of function <code class="code">subst</code> applied to the substrings
    of the match. Uses <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code>
    otherwise. Callouts are handled by <code class="code">callout</code>.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALsubstitute"><span class="keyword">val</span> substitute</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -><br>       ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> subst:(string -> string) -> string -> string</code></pre><div class="info ">
<code class="code">substitute ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code>
    replaces all substrings of <code class="code">subj</code> matching pattern <code class="code">pat</code> when given,
    regular expression <code class="code">rex</code> otherwise, starting at position <code class="code">pos</code> with
    the result of function <code class="code">subst</code> applied to the match. Uses <code class="code">flags</code>
    when given, the precompiled <code class="code">iflags</code> otherwise. Callouts are handled
    by <code class="code">callout</code>.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALreplace_first"><span class="keyword">val</span> replace_first</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -><br>       ?itempl:<a href="Pcre.html#TYPEsubstitution">substitution</a> -><br>       ?templ:string -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> string</code></pre><div class="info ">
<code class="code">replace_first ?iflags ?flags ?rex ?pat ?pos ?itempl ?templ ?callout subj</code>
    replaces the first substring of <code class="code">subj</code> matching pattern <code class="code">pat</code> when
    given, regular expression <code class="code">rex</code> otherwise, starting at position
    <code class="code">pos</code> with the substitution string <code class="code">templ</code> when given, <code class="code">itempl</code>
    otherwise. Uses <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code>
    otherwise. Callouts are handled by <code class="code">callout</code>.<br>
<b>Raises</b> <code>Failure</code> if there are backreferences to nonexistent subpatterns.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">itempl</code> : default = empty string</div>
<div class="param_info"><code class="code">templ</code> : default = ignored</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALqreplace_first"><span class="keyword">val</span> qreplace_first</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -> ?templ:string -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> string</code></pre><div class="info ">
<code class="code">qreplace_first ?iflags ?flags ?rex ?pat ?pos ?templ ?callout subj</code>
    replaces the first substring of <code class="code">subj</code> matching pattern <code class="code">pat</code> when
    given, regular expression <code class="code">rex</code> otherwise, starting at position <code class="code">pos</code>
    with the string <code class="code">templ</code>. Uses <code class="code">flags</code> when given, the precompiled
    <code class="code">iflags</code> otherwise. Callouts are handled by <code class="code">callout</code>.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">templ</code> : default = ignored</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALsubstitute_substrings_first"><span class="keyword">val</span> substitute_substrings_first</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -><br>       ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -><br>       subst:(<a href="Pcre.html#TYPEsubstrings">substrings</a> -> string) -> string -> string</code></pre><div class="info ">
<code class="code">substitute_substrings_first
       ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code>
    replaces the first substring of <code class="code">subj</code> matching pattern <code class="code">pat</code> when
    given, regular expression <code class="code">rex</code> otherwise, starting at position
    <code class="code">pos</code> with the result of function <code class="code">subst</code> applied to the substrings
    of the match. Uses <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code>
    otherwise. Callouts are handled by <code class="code">callout</code>.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALsubstitute_first"><span class="keyword">val</span> substitute_first</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -><br>       ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> subst:(string -> string) -> string -> string</code></pre><div class="info ">
<code class="code">substitute_first ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code>
    replaces the first substring of <code class="code">subj</code> matching pattern <code class="code">pat</code> when
    given, regular expression <code class="code">rex</code> otherwise, starting at position
    <code class="code">pos</code> with the result of function <code class="code">subst</code> applied to the match. Uses
    <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code> otherwise. Callouts
    are handled by <code class="code">callout</code>.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>
<br>
<h6 id="6_Splitting">Splitting</h6><br>

<pre><span id="VALsplit"><span class="keyword">val</span> split</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -> ?max:int -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> string list</code></pre><div class="info ">
<code class="code">split ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> splits <code class="code">subj</code>
    into a list of at most <code class="code">max</code> strings, using as delimiter pattern
    <code class="code">pat</code> when given, regular expression <code class="code">rex</code> otherwise, starting at
    position <code class="code">pos</code>. Uses <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code>
    otherwise. If <code class="code">max</code> is zero, trailing empty fields are stripped. If
    it is negative, it is treated as arbitrarily large. If neither <code class="code">pat</code>
    nor <code class="code">rex</code> are specified, leading whitespace will be stripped! Should
    behave exactly as in PERL. Callouts are handled by <code class="code">callout</code>.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">max</code> : default = 0</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>

<pre><span id="VALasplit"><span class="keyword">val</span> asplit</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -> ?max:int -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> string array</code></pre><div class="info ">
<code class="code">asplit ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> same as
    <a href="Pcre.html#VALsplit"><code class="code">Pcre.split</code></a> but<br>
<b>Returns</b> an array instead of a list.<br>
</div>

<pre><code><span id="TYPEsplit_result"><span class="keyword">type</span> <code class="type"></code>split_result</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsplit_result.Text"><span class="constructor">Text</span></span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Text part of split string<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsplit_result.Delim"><span class="constructor">Delim</span></span> <span class="keyword">of</span> <code class="type">string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Delimiter part of split string<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsplit_result.Group"><span class="constructor">Group</span></span> <span class="keyword">of</span> <code class="type">int * string</code></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Subgroup of matched delimiter
                                              (subgroup_nr, subgroup_str)<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTsplit_result.NoGroup"><span class="constructor">NoGroup</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Unmatched subgroup<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>

<div class="info ">
Result of a <a href="Pcre.html#VALfull_split"><code class="code">Pcre.full_split</code></a><br>
</div>


<pre><span id="VALfull_split"><span class="keyword">val</span> full_split</span> : <code class="type">?iflags:<a href="Pcre.html#TYPEirflag">irflag</a> -><br>       ?flags:<a href="Pcre.html#TYPErflag">rflag</a> list -><br>       ?rex:<a href="Pcre.html#TYPEregexp">regexp</a> -><br>       ?pat:string -><br>       ?pos:int -><br>       ?max:int -> ?callout:<a href="Pcre.html#TYPEcallout">callout</a> -> string -> <a href="Pcre.html#TYPEsplit_result">split_result</a> list</code></pre><div class="info ">
<code class="code">full_split ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> splits
    <code class="code">subj</code> into a list of at most <code class="code">max</code> elements of type "split_result",
    using as delimiter pattern <code class="code">pat</code> when given, regular expression
    <code class="code">rex</code> otherwise, starting at position <code class="code">pos</code>. Uses <code class="code">flags</code> when given,
    the precompiled <code class="code">iflags</code> otherwise. If <code class="code">max</code> is zero, trailing empty
    fields are stripped. If it is negative, it is treated as arbitrarily
    large. Should behave exactly as in PERL. Callouts are handled by
    <code class="code">callout</code>.<br>
</div>
<div class="param_info"><code class="code">iflags</code> : default = no extra flags</div>
<div class="param_info"><code class="code">flags</code> : default = ignored</div>
<div class="param_info"><code class="code">rex</code> : default = matches whitespace</div>
<div class="param_info"><code class="code">pat</code> : default = ignored</div>
<div class="param_info"><code class="code">pos</code> : default = 0</div>
<div class="param_info"><code class="code">max</code> : default = 0</div>
<div class="param_info"><code class="code">callout</code> : default = ignore callouts</div>
<br>
<h6 id="6_Additionalconveniencefunctions">Additional convenience functions</h6><br>

<pre><span id="VALforeach_line"><span class="keyword">val</span> foreach_line</span> : <code class="type">?ic:Pervasives.in_channel -> (string -> unit) -> unit</code></pre><div class="info ">
<code class="code">foreach_line ?ic f</code> applies <code class="code">f</code> to each line in inchannel <code class="code">ic</code> until
    the end-of-file is reached.<br>
</div>
<div class="param_info"><code class="code">ic</code> : default = stdin</div>

<pre><span id="VALforeach_file"><span class="keyword">val</span> foreach_file</span> : <code class="type">string list -> (string -> Pervasives.in_channel -> unit) -> unit</code></pre><div class="info ">
<code class="code">foreach_file filenames f</code> opens each file in the list <code class="code">filenames</code>
    for input and applies <code class="code">f</code> to each filename and the corresponding
    channel. Channels are closed after each operation (even when
    exceptions occur - they get reraised afterwards!).<br>
</div>
<br>
<h6 id="6_UNSAFESTUFFUSEWITHCAUTION"><b>UNSAFE STUFF - USE WITH CAUTION!</b></h6><br>

<pre><span id="VALunsafe_pcre_exec"><span class="keyword">val</span> unsafe_pcre_exec</span> : <code class="type"><a href="Pcre.html#TYPEirflag">irflag</a> -><br>       <a href="Pcre.html#TYPEregexp">regexp</a> -><br>       pos:int -><br>       subj_start:int -> subj:string -> int array -> <a href="Pcre.html#TYPEcallout">callout</a> option -> unit</code></pre><div class="info ">
<code class="code">unsafe_pcre_exec flags rex ~pos ~subj_start ~subj offset_vector</code>.
    You should read the C-source to know what happens.
    If you do not understand it - <b>don't use this function!</b><br>
</div>

<pre><span id="VALmake_ovector"><span class="keyword">val</span> make_ovector</span> : <code class="type"><a href="Pcre.html#TYPEregexp">regexp</a> -> int * int array</code></pre><div class="info ">
<code class="code">make_ovector regexp</code> calculates the tuple (subgroups2, ovector)
    which is the number of subgroup offsets and the offset array.<br>
</div>
</body></html>