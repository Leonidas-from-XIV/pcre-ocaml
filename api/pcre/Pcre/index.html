<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pcre (pcre.Pcre)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../index.html">pcre</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Pcre</span></h1></header><p>Perl Compatibility Regular Expressions for OCaml</p><p><em>7.3.2 - <a href="https://mmottl.github.io/pcre-ocaml">homepage</a></em></p><div class="h7">Exceptions</div><div class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>error</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-error.Partial" class="anchored"><td class="def constructor"><a href="#type-error.Partial" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Partial</span></code></td><td class="doc"><p>(** String only matched the pattern partially *)</p></td></tr><tr id="type-error.BadPartial" class="anchored"><td class="def constructor"><a href="#type-error.BadPartial" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">BadPartial</span></code></td><td class="doc"><p>(** Pattern contains items that cannot be used together
with partial matching. *)</p></td></tr><tr id="type-error.BadPattern" class="anchored"><td class="def constructor"><a href="#type-error.BadPattern" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">BadPattern</span><span class="keyword"> of </span>string<span class="keyword"> * </span>int</code></td><td class="doc"><p>(** <code class="code">BadPattern (msg, pos)</code> regular
expression is malformed. The reason
is in <code class="code">msg</code>, the position of the
error in the pattern in <code class="code">pos</code>. *)</p></td></tr><tr id="type-error.BadUTF8" class="anchored"><td class="def constructor"><a href="#type-error.BadUTF8" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">BadUTF8</span></code></td><td class="doc"><p>(** UTF8 string being matched is invalid *)</p></td></tr><tr id="type-error.BadUTF8Offset" class="anchored"><td class="def constructor"><a href="#type-error.BadUTF8Offset" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">BadUTF8Offset</span></code></td><td class="doc"><p>(** Gets raised when a UTF8 string being matched with
offset is invalid. *)</p></td></tr><tr id="type-error.MatchLimit" class="anchored"><td class="def constructor"><a href="#type-error.MatchLimit" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">MatchLimit</span></code></td><td class="doc"><p>(** Maximum allowed number of match attempts with
backtracking or recursion is reached during matching.
ALL FUNCTIONS CALLING THE MATCHING ENGINE MAY RAISE
IT!!! *)</p></td></tr><tr id="type-error.RecursionLimit" class="anchored"><td class="def constructor"><a href="#type-error.RecursionLimit" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">RecursionLimit</span></code></td></tr><tr id="type-error.InternalError" class="anchored"><td class="def constructor"><a href="#type-error.InternalError" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">InternalError</span><span class="keyword"> of </span>string</code></td><td class="doc"><p>(** <code class="code">InternalError msg</code> C-library exhibits unknown/undefined
behaviour. The reason is in <code class="code">msg</code>. *)</p></td></tr></table><code></code></div><div class="doc"></div></div><div class="spec exception" id="exception-Error"><a href="#exception-Error" class="anchor"></a><div class="def exception"><code><span class="keyword">exception </span></code><code><span class="exception">Error</span><span class="keyword"> of </span><a href="index.html#type-error">error</a></code></div><div class="doc"><p>Exception indicating PCRE errors.</p></div></div><div class="spec exception" id="exception-Backtrack"><a href="#exception-Backtrack" class="anchor"></a><div class="def exception"><code><span class="keyword">exception </span></code><code><span class="exception">Backtrack</span></code></div><div class="doc"><p><code class="code">Backtrack</code> used in callout functions to force backtracking.</p></div></div><div class="spec exception" id="exception-Regexp_or"><a href="#exception-Regexp_or" class="anchor"></a><div class="def exception"><code><span class="keyword">exception </span></code><code><span class="exception">Regexp_or</span><span class="keyword"> of </span>string<span class="keyword"> * </span><a href="index.html#type-error">error</a></code></div><div class="doc"><p><code class="code">Regexp_or (pat, error)</code> gets raised for sub-pattern <code class="code">pat</code> by <code class="code">regexp_or</code>
if it failed to compile.</p></div></div><div class="h7">Compilation and runtime flags and their conversion functions</div><div class="spec type" id="type-icflag"><a href="#type-icflag" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>icflag</code><code></code><code></code></div><div class="doc"><p>Internal representation of compilation flags</p></div></div><div class="spec type" id="type-irflag"><a href="#type-irflag" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>irflag</code><code></code><code></code></div><div class="doc"><p>Internal representation of runtime flags</p></div></div><div class="spec type" id="type-cflag"><a href="#type-cflag" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>cflag</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-cflag.CASELESS" class="anchored"><td class="def constructor"><a href="#type-cflag.CASELESS" class="anchor"></a><code><span class="keyword">| </span></code><code>`CASELESS</code></td></tr><tr id="type-cflag.MULTILINE" class="anchored"><td class="def constructor"><a href="#type-cflag.MULTILINE" class="anchor"></a><code><span class="keyword">| </span></code><code>`MULTILINE</code></td></tr><tr id="type-cflag.DOTALL" class="anchored"><td class="def constructor"><a href="#type-cflag.DOTALL" class="anchor"></a><code><span class="keyword">| </span></code><code>`DOTALL</code></td></tr><tr id="type-cflag.EXTENDED" class="anchored"><td class="def constructor"><a href="#type-cflag.EXTENDED" class="anchor"></a><code><span class="keyword">| </span></code><code>`EXTENDED</code></td></tr><tr id="type-cflag.ANCHORED" class="anchored"><td class="def constructor"><a href="#type-cflag.ANCHORED" class="anchor"></a><code><span class="keyword">| </span></code><code>`ANCHORED</code></td></tr><tr id="type-cflag.DOLLAR_ENDONLY" class="anchored"><td class="def constructor"><a href="#type-cflag.DOLLAR_ENDONLY" class="anchor"></a><code><span class="keyword">| </span></code><code>`DOLLAR_ENDONLY</code></td></tr><tr id="type-cflag.EXTRA" class="anchored"><td class="def constructor"><a href="#type-cflag.EXTRA" class="anchor"></a><code><span class="keyword">| </span></code><code>`EXTRA</code></td></tr><tr id="type-cflag.UNGREEDY" class="anchored"><td class="def constructor"><a href="#type-cflag.UNGREEDY" class="anchor"></a><code><span class="keyword">| </span></code><code>`UNGREEDY</code></td></tr><tr id="type-cflag.UTF8" class="anchored"><td class="def constructor"><a href="#type-cflag.UTF8" class="anchor"></a><code><span class="keyword">| </span></code><code>`UTF8</code></td></tr><tr id="type-cflag.NO_UTF8_CHECK" class="anchored"><td class="def constructor"><a href="#type-cflag.NO_UTF8_CHECK" class="anchor"></a><code><span class="keyword">| </span></code><code>`NO_UTF8_CHECK</code></td></tr><tr id="type-cflag.NO_AUTO_CAPTURE" class="anchored"><td class="def constructor"><a href="#type-cflag.NO_AUTO_CAPTURE" class="anchor"></a><code><span class="keyword">| </span></code><code>`NO_AUTO_CAPTURE</code></td></tr><tr id="type-cflag.AUTO_CALLOUT" class="anchored"><td class="def constructor"><a href="#type-cflag.AUTO_CALLOUT" class="anchor"></a><code><span class="keyword">| </span></code><code>`AUTO_CALLOUT</code></td></tr><tr id="type-cflag.FIRSTLINE" class="anchored"><td class="def constructor"><a href="#type-cflag.FIRSTLINE" class="anchor"></a><code><span class="keyword">| </span></code><code>`FIRSTLINE</code></td></tr></table><code> ]</code><code></code></div><div class="doc"><p>Compilation flags</p></div></div><div class="spec val" id="val-cflags"><a href="#val-cflags" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cflags : <a href="index.html#type-cflag">cflag</a> list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-icflag">icflag</a></code></div><div class="doc"><p><code class="code">cflags cflag_list</code> converts a list of compilation flags to
their internal representation.</p></div></div><div class="spec val" id="val-cflag_list"><a href="#val-cflag_list" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cflag_list : <a href="index.html#type-icflag">icflag</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-cflag">cflag</a> list</code></div><div class="doc"><p><code class="code">cflag_list cflags</code> converts internal representation of
compilation flags to a list.</p></div></div><div class="spec type" id="type-rflag"><a href="#type-rflag" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>rflag</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-rflag.ANCHORED" class="anchored"><td class="def constructor"><a href="#type-rflag.ANCHORED" class="anchor"></a><code><span class="keyword">| </span></code><code>`ANCHORED</code></td></tr><tr id="type-rflag.NOTBOL" class="anchored"><td class="def constructor"><a href="#type-rflag.NOTBOL" class="anchor"></a><code><span class="keyword">| </span></code><code>`NOTBOL</code></td></tr><tr id="type-rflag.NOTEOL" class="anchored"><td class="def constructor"><a href="#type-rflag.NOTEOL" class="anchor"></a><code><span class="keyword">| </span></code><code>`NOTEOL</code></td></tr><tr id="type-rflag.NOTEMPTY" class="anchored"><td class="def constructor"><a href="#type-rflag.NOTEMPTY" class="anchor"></a><code><span class="keyword">| </span></code><code>`NOTEMPTY</code></td></tr><tr id="type-rflag.PARTIAL" class="anchored"><td class="def constructor"><a href="#type-rflag.PARTIAL" class="anchor"></a><code><span class="keyword">| </span></code><code>`PARTIAL</code></td></tr></table><code> ]</code><code></code></div><div class="doc"><p>Runtime flags</p></div></div><div class="spec val" id="val-rflags"><a href="#val-rflags" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>rflags : <a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-irflag">irflag</a></code></div><div class="doc"><p><code class="code">rflags rflag_list</code> converts a list of runtime flags to
their internal representation.</p></div></div><div class="spec val" id="val-rflag_list"><a href="#val-rflag_list" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>rflag_list : <a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-rflag">rflag</a> list</code></div><div class="doc"><p><code class="code">rflag_list rflags</code> converts internal representation of
runtime flags to a list.</p></div></div><div class="h7">Information on the PCRE-configuration (build-time options)</div><div class="spec val" id="val-version"><a href="#val-version" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>version : string</code></div><div class="doc"><p>Version information</p><p>Version of the PCRE-C-library</p></div></div><div class="spec val" id="val-config_utf8"><a href="#val-config_utf8" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>config_utf8 : bool</code></div><div class="doc"><p>Indicates whether UTF8-support is enabled</p></div></div><div class="spec val" id="val-config_newline"><a href="#val-config_newline" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>config_newline : char</code></div><div class="doc"><p>Character used as newline</p></div></div><div class="spec val" id="val-config_link_size"><a href="#val-config_link_size" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>config_link_size : int</code></div><div class="doc"><p>Number of bytes used for internal linkage of regular expressions</p></div></div><div class="spec val" id="val-config_match_limit"><a href="#val-config_match_limit" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>config_match_limit : int</code></div><div class="doc"><p>Default limit for calls to internal matching function</p></div></div><div class="spec val" id="val-config_match_limit_recursion"><a href="#val-config_match_limit_recursion" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>config_match_limit_recursion : int</code></div><div class="doc"><p>Default limit recursion for calls to internal matching function</p></div></div><div class="spec val" id="val-config_stackrecurse"><a href="#val-config_stackrecurse" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>config_stackrecurse : bool</code></div><div class="doc"><p>Indicates use of stack recursion in matching function</p></div></div><div class="h7">Information on patterns</div><div class="spec type" id="type-firstbyte_info"><a href="#type-firstbyte_info" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>firstbyte_info</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-firstbyte_info.Char" class="anchored"><td class="def constructor"><a href="#type-firstbyte_info.Char" class="anchor"></a><code><span class="keyword">| </span></code><code>`Char<span class="keyword"> of </span>char</code></td></tr><tr id="type-firstbyte_info.Start_only" class="anchored"><td class="def constructor"><a href="#type-firstbyte_info.Start_only" class="anchor"></a><code><span class="keyword">| </span></code><code>`Start_only</code></td></tr><tr id="type-firstbyte_info.ANCHORED" class="anchored"><td class="def constructor"><a href="#type-firstbyte_info.ANCHORED" class="anchor"></a><code><span class="keyword">| </span></code><code>`ANCHORED</code></td></tr></table><code> ]</code><code></code></div><div class="doc"><p>Information on matching of &quot;first chars&quot; in patterns</p></div></div><div class="spec type" id="type-study_stat"><a href="#type-study_stat" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>study_stat</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-study_stat.Not_studied" class="anchored"><td class="def constructor"><a href="#type-study_stat.Not_studied" class="anchor"></a><code><span class="keyword">| </span></code><code>`Not_studied</code></td></tr><tr id="type-study_stat.Studied" class="anchored"><td class="def constructor"><a href="#type-study_stat.Studied" class="anchor"></a><code><span class="keyword">| </span></code><code>`Studied</code></td></tr><tr id="type-study_stat.Optimal" class="anchored"><td class="def constructor"><a href="#type-study_stat.Optimal" class="anchor"></a><code><span class="keyword">| </span></code><code>`Optimal</code></td></tr></table><code> ]</code><code></code></div><div class="doc"><p>Information on the study status of patterns</p></div></div><div class="spec type" id="type-regexp"><a href="#type-regexp" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>regexp</code><code></code><code></code></div><div class="doc"><p>Compiled regular expressions</p></div></div><div class="spec val" id="val-options"><a href="#val-options" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>options : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-icflag">icflag</a></code></div><div class="doc"><p><code class="code">options regexp</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> compilation flags of <code class="code">regexp</code>.</li></ul></div></div><div class="spec val" id="val-size"><a href="#val-size" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>size : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">size regexp</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> memory size of <code class="code">regexp</code>.</li></ul></div></div><div class="spec val" id="val-studysize"><a href="#val-studysize" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>studysize : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">studysize regexp</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> memory size of study information of <code class="code">regexp</code>.</li></ul></div></div><div class="spec val" id="val-capturecount"><a href="#val-capturecount" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>capturecount : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">capturecount regexp</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> number of capturing subpatterns in
<code class="code">regexp</code>.</li></ul></div></div><div class="spec val" id="val-backrefmax"><a href="#val-backrefmax" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>backrefmax : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">backrefmax regexp</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> number of highest backreference in <code class="code">regexp</code>.</li></ul></div></div><div class="spec val" id="val-namecount"><a href="#val-namecount" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>namecount : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">namecount regexp</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> number of named subpatterns in <code class="code">regexp</code>.</li></ul></div></div><div class="spec val" id="val-nameentrysize"><a href="#val-nameentrysize" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>nameentrysize : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">nameentrysize regexp</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> size of longest name of named
subpatterns in <code class="code">regexp</code> + 3.</li></ul></div></div><div class="spec val" id="val-names"><a href="#val-names" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>names : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> string array</code></div><div class="doc"><p><code class="code">names regex</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> array of names of named substrings in <code class="code">regexp</code>.</li></ul></div></div><div class="spec val" id="val-firstbyte"><a href="#val-firstbyte" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>firstbyte : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-firstbyte_info">firstbyte_info</a></code></div><div class="doc"><p><code class="code">firstbyte regexp</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> firstbyte info on <code class="code">regexp</code>.</li></ul></div></div><div class="spec val" id="val-firsttable"><a href="#val-firsttable" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>firsttable : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> string option</code></div><div class="doc"><p><code class="code">firsttable regexp</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> some 256-bit (32-byte) fixed set table in
form of a string for <code class="code">regexp</code> if available, <code class="code">None</code> otherwise.</li></ul></div></div><div class="spec val" id="val-lastliteral"><a href="#val-lastliteral" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>lastliteral : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> char option</code></div><div class="doc"><p><code class="code">lastliteral regexp</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> some last matching character of <code class="code">regexp</code>
if available, <code class="code">None</code> otherwise.</li></ul></div></div><div class="spec val" id="val-study_stat"><a href="#val-study_stat" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>study_stat : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-study_stat">study_stat</a></code></div><div class="doc"><p><code class="code">study_stat regexp</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> study status of <code class="code">regexp</code>.</li></ul></div></div><div class="spec val" id="val-get_stringnumber"><a href="#val-get_stringnumber" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_stringnumber : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">get_stringnumber rex name</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the index of the named substring
<code class="code">name</code> in regular expression <code class="code">rex</code>. This index can then be used with
<code class="code">get_substring</code>.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_arg</span>: if there is no such named substring.</li></ul></div></div><div class="spec val" id="val-get_match_limit"><a href="#val-get_match_limit" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_match_limit : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> int option</code></div><div class="doc"><p><code class="code">get_match_limit rex</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> some match limit of regular expression
<code class="code">rex</code> or <code class="code">None</code>.</li></ul></div></div><div class="spec val" id="val-get_match_limit_recursion"><a href="#val-get_match_limit_recursion" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_match_limit_recursion : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> int option</code></div><div class="doc"><p><code class="code">get_match_limit_recursion rex</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> some recursion match limit
of regular expression <code class="code">rex</code> or <code class="code">None</code>.</li></ul></div></div><div class="h7">Compilation of patterns</div><div class="spec type" id="type-chtables"><a href="#type-chtables" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>chtables</code><code></code><code></code></div><div class="doc"><p>Alternative set of char tables for pattern matching</p></div></div><div class="spec val" id="val-maketables"><a href="#val-maketables" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>maketables : unit <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-chtables">chtables</a></code></div><div class="doc"><p>Generates new set of char tables for the current locale.</p></div></div><div class="spec val" id="val-regexp"><a href="#val-regexp" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>regexp : ?&#8288;study:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;limit:int <span class="keyword">&#8209;&gt;</span> ?&#8288;limit_recursion:int <span class="keyword">&#8209;&gt;</span> ?&#8288;iflags:<a href="index.html#type-icflag">icflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-cflag">cflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;chtables:<a href="index.html#type-chtables">chtables</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-regexp">regexp</a></code></div><div class="doc"><p><code class="code">regexp ?study ?limit ?limit_recursion ?iflags ?flags ?chtables pattern</code>
compiles <code class="code">pattern</code> with <code class="code">flags</code> when given, with <code class="code">iflags</code> otherwise, and
with char tables <code class="code">chtables</code>. If <code class="code">study</code> is true, then the resulting regular
expression will be studied. If <code class="code">limit</code> is specified, this sets a limit to
the amount of recursion and backtracking (only lower than the builtin
default!). If this limit is exceeded, <code class="code">MatchLimit</code> will be raised during
matching.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">study</span>: default = true</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">limit</span>: default = no extra limit other than default</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">limit_recursion</span>: default = no extra limit_recursion other than default</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">chtables</span>: default = builtin char tables</li><li><p><span class="at-tag return">Returns</span> the regular expression.</p><p>For detailed documentation on how you can specify PERL-style regular
expressions (= patterns), please consult the PCRE-documentation
(&quot;man pcrepattern&quot;) or PERL-manuals.</p></li><li><span class="at-tag see">See</span> <a href="http://www.perl.com">http://www.perl.com</a>www.perl.com</li></ul></div></div><div class="spec val" id="val-regexp_or"><a href="#val-regexp_or" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>regexp_or : ?&#8288;study:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;limit:int <span class="keyword">&#8209;&gt;</span> ?&#8288;limit_recursion:int <span class="keyword">&#8209;&gt;</span> ?&#8288;iflags:<a href="index.html#type-icflag">icflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-cflag">cflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;chtables:<a href="index.html#type-chtables">chtables</a> <span class="keyword">&#8209;&gt;</span> string list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-regexp">regexp</a></code></div><div class="doc"><p><code class="code">regexp_or ?study ?limit ?limit_recursion ?iflags ?flags ?chtables patterns</code>
like <a href="index.html#type-regexp">regexp</a>, but combines <code class="code">patterns</code> as alternatives (or-patterns) into
one regular expression.</p></div></div><div class="spec val" id="val-quote"><a href="#val-quote" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>quote : string <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p><code class="code">quote str</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the quoted string of <code class="code">str</code>.</li></ul></div></div><div class="h7">Subpattern extraction</div><div class="spec type" id="type-substrings"><a href="#type-substrings" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>substrings</code><code></code><code></code></div><div class="doc"><p>Information on substrings after pattern matching</p></div></div><div class="spec val" id="val-get_subject"><a href="#val-get_subject" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_subject : <a href="index.html#type-substrings">substrings</a> <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p><code class="code">get_subject substrings</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the subject string of <code class="code">substrings</code>.</li></ul></div></div><div class="spec val" id="val-num_of_subs"><a href="#val-num_of_subs" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>num_of_subs : <a href="index.html#type-substrings">substrings</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">num_of_subs substrings</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> number of strings in <code class="code">substrings</code>
(whole match inclusive).</li></ul></div></div><div class="spec val" id="val-get_substring"><a href="#val-get_substring" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_substring : <a href="index.html#type-substrings">substrings</a> <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p><code class="code">get_substring substrings n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the <code class="code">n</code>th substring
(0 is whole match) of <code class="code">substrings</code>.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_argument</span>: if <code class="code">n</code> is not in the range of the number of
substrings.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Not_found</span>: if the corresponding subpattern did not capture
a substring.</li></ul></div></div><div class="spec val" id="val-get_substring_ofs"><a href="#val-get_substring_ofs" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_substring_ofs : <a href="index.html#type-substrings">substrings</a> <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> int<span class="keyword"> * </span>int</code></div><div class="doc"><p><code class="code">get_substring_ofs substrings n</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the offset tuple of the
<code class="code">n</code>th substring of <code class="code">substrings</code> (0 is whole match).</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_argument</span>: if <code class="code">n</code> is not in the range of the number
of substrings.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Not_found</span>: if the corresponding subpattern did not capture
a substring.</li></ul></div></div><div class="spec val" id="val-get_substrings"><a href="#val-get_substrings" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_substrings : ?&#8288;full_match:bool <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span class="keyword">&#8209;&gt;</span> string array</code></div><div class="doc"><p><code class="code">get_substrings ?full_match substrings</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the array of
substrings in <code class="code">substrings</code>. It includes the full match at index 0
when <code class="code">full_match</code> is <code class="code">true</code>, the captured substrings only when it
is <code class="code">false</code>. If a subpattern did not capture a substring, the empty
string is returned in the corresponding position instead.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">full_match</span>: default = true</li></ul></div></div><div class="spec val" id="val-get_opt_substrings"><a href="#val-get_opt_substrings" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_opt_substrings : ?&#8288;full_match:bool <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span class="keyword">&#8209;&gt;</span> string option array</code></div><div class="doc"><p><code class="code">get_opt_substrings ?full_match substrings</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the array of
optional substrings in <code class="code">substrings</code>. It includes <code class="code">Some full_match_str</code>
at index 0 when <code class="code">full_match</code> is <code class="code">true</code>, <code class="code">Some captured_substrings</code>
only when it is <code class="code">false</code>. If a subpattern did not capture a substring,
<code class="code">None</code> is returned in the corresponding position instead.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">full_match</span>: default = true</li></ul></div></div><div class="spec val" id="val-get_named_substring"><a href="#val-get_named_substring" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_named_substring : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p><code class="code">get_named_substring rex name substrings</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the named substring
<code class="code">name</code> in regular expression <code class="code">rex</code> and <code class="code">substrings</code>.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_argument</span>: if there is no such named substring.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Not_found</span>: if the corresponding subpattern did not capture
a substring.</li></ul></div></div><div class="spec val" id="val-get_named_substring_ofs"><a href="#val-get_named_substring_ofs" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_named_substring_ofs : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span class="keyword">&#8209;&gt;</span> int<span class="keyword"> * </span>int</code></div><div class="doc"><p><code class="code">get_named_substring_ofs rex name substrings</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the offset
tuple of the named substring <code class="code">name</code> in regular expression <code class="code">rex</code> and
<code class="code">substrings</code>.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_argument</span>: if there is no such named substring.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Not_found</span>: if the corresponding subpattern did not capture
a substring.</li></ul></div></div><div class="h7">Callouts</div><div class="spec type" id="type-callout_data"><a href="#type-callout_data" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>callout_data</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-callout_data.callout_number" class="anchored"><td class="def field"><a href="#type-callout_data.callout_number" class="anchor"></a><code>callout_number : int;</code></td><td class="doc"><p>(** Callout number *)</p></td></tr><tr id="type-callout_data.substrings" class="anchored"><td class="def field"><a href="#type-callout_data.substrings" class="anchor"></a><code>substrings : <a href="index.html#type-substrings">substrings</a>;</code></td><td class="doc"><p>(** Substrings matched so far *)</p></td></tr><tr id="type-callout_data.start_match" class="anchored"><td class="def field"><a href="#type-callout_data.start_match" class="anchor"></a><code>start_match : int;</code></td><td class="doc"><p>(** Subject start offset of current match attempt *)</p></td></tr><tr id="type-callout_data.current_position" class="anchored"><td class="def field"><a href="#type-callout_data.current_position" class="anchor"></a><code>current_position : int;</code></td><td class="doc"><p>(** Subject offset of current match pointer *)</p></td></tr><tr id="type-callout_data.capture_top" class="anchored"><td class="def field"><a href="#type-callout_data.capture_top" class="anchor"></a><code>capture_top : int;</code></td><td class="doc"><p>(** Number of the highest captured substring so far *)</p></td></tr><tr id="type-callout_data.capture_last" class="anchored"><td class="def field"><a href="#type-callout_data.capture_last" class="anchor"></a><code>capture_last : int;</code></td><td class="doc"><p>(** Number of the most recently captured substring *)</p></td></tr><tr id="type-callout_data.pattern_position" class="anchored"><td class="def field"><a href="#type-callout_data.pattern_position" class="anchor"></a><code>pattern_position : int;</code></td><td class="doc"><p>(** Offset of next match item in pattern string *)</p></td></tr><tr id="type-callout_data.next_item_length" class="anchored"><td class="def field"><a href="#type-callout_data.next_item_length" class="anchor"></a><code>next_item_length : int;</code></td><td class="doc"><p>(** Length of next match item in pattern string *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"></div></div><div class="spec type" id="type-callout"><a href="#type-callout" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>callout</code><code><span class="keyword"> = </span><a href="index.html#type-callout_data">callout_data</a> <span class="keyword">&#8209;&gt;</span> unit</code><code></code></div><div class="doc"><p>Type of callout functions</p><p>Callouts are referred to in patterns as &quot;(?Cn)&quot; where &quot;n&quot; is a
<code class="code">callout_number</code> ranging from 0 to 255. Substrings captured so far
are accessible as usual via <code class="code">substrings</code>. You will have to consider
<code class="code">capture_top</code> and <code class="code">capture_last</code> to know about the current state of
valid substrings.</p><p>By raising exception <code class="code">Backtrack</code> within a callout function, the user
can force the pattern matching engine to backtrack to other possible
solutions. Other exceptions will terminate matching immediately
and return control to OCaml.</p></div></div><div class="h7">Matching of patterns and subpattern extraction</div><div class="spec val" id="val-pcre_exec"><a href="#val-pcre_exec" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pcre_exec : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> int array</code></div><div class="doc"><p><code class="code">pcre_exec ?iflags ?flags ?rex ?pat ?pos ?callout subj</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> an
array of offsets that describe the position of matched subpatterns in
the string <code class="code">subj</code> starting at position <code class="code">pos</code> with pattern <code class="code">pat</code> when
given, regular expression <code class="code">rex</code> otherwise. The array also contains
additional workspace needed by the match engine. Uses <code class="code">flags</code> when
given, the precompiled <code class="code">iflags</code> otherwise. Callouts are handled by
<code class="code">callout</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Not_found</span>: if pattern does not match.</li></ul></div></div><div class="spec val" id="val-exec"><a href="#val-exec" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>exec : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-substrings">substrings</a></code></div><div class="doc"><p><code class="code">exec ?iflags ?flags ?rex ?pat ?pos ?callout subj</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> substring
information on string <code class="code">subj</code> starting at position <code class="code">pos</code> with pattern
<code class="code">pat</code> when given, regular expression <code class="code">rex</code> otherwise. Uses <code class="code">flags</code>
when given, the precompiled <code class="code">iflags</code> otherwise. Callouts are handled
by <code class="code">callout</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Not_found</span>: if pattern does not match.</li></ul></div></div><div class="spec val" id="val-exec_all"><a href="#val-exec_all" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>exec_all : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-substrings">substrings</a> array</code></div><div class="doc"><p><code class="code">exec_all ?iflags ?flags ?rex ?pat ?pos ?callout subj</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> an array of substring information of all matching substrings in
string <code class="code">subj</code> starting at position <code class="code">pos</code> with pattern <code class="code">pat</code> when
given, regular expression <code class="code">rex</code> otherwise. Uses <code class="code">flags</code> when given,
the precompiled <code class="code">iflags</code> otherwise. Callouts are handled by <code class="code">callout</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Not_found</span>: if pattern does not match.</li></ul></div></div><div class="spec val" id="val-next_match"><a href="#val-next_match" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>next_match : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-substrings">substrings</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-substrings">substrings</a></code></div><div class="doc"><p><code class="code">next_match ?iflags ?flags ?rex ?pat ?pos ?callout substrs</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> substring information on the match that follows on the last
match denoted by <code class="code">substrs</code>, jumping over <code class="code">pos</code> characters (also
backwards!), using pattern <code class="code">pat</code> when given, regular expression
<code class="code">rex</code> otherwise. Uses <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code>
otherwise. Callouts are handled by <code class="code">callout</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Not_found</span>: if pattern does not match.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_arg</span>: if <code class="code">pos</code> let matching start outside of
the subject string.</li></ul></div></div><div class="spec val" id="val-extract"><a href="#val-extract" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>extract : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;full_match:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> string array</code></div><div class="doc"><p><code class="code">extract ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the array of substrings that match <code class="code">subj</code> starting at
position <code class="code">pos</code>, using pattern <code class="code">pat</code> when given, regular expression
<code class="code">rex</code> otherwise. Uses <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code>
otherwise. It includes the full match at index 0 when <code class="code">full_match</code> is
<code class="code">true</code>, the captured substrings only when it is <code class="code">false</code>. Callouts are
handled by <code class="code">callout</code>. If a subpattern did not capture a substring,
the empty string is returned in the corresponding position instead.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">full_match</span>: default = true</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Not_found</span>: if pattern does not match.</li></ul></div></div><div class="spec val" id="val-extract_opt"><a href="#val-extract_opt" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>extract_opt : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;full_match:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> string option array</code></div><div class="doc"><p><code class="code">extract_opt ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> the array of optional substrings that match <code class="code">subj</code> starting
at position <code class="code">pos</code>, using pattern <code class="code">pat</code> when given, regular expression
<code class="code">rex</code> otherwise. Uses <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code>
otherwise. It includes <code class="code">Some full_match_str</code> at index 0 when
<code class="code">full_match</code> is <code class="code">true</code>, <code class="code">Some captured-substrings</code> only when it is
<code class="code">false</code>. Callouts are handled by <code class="code">callout</code>. If a subpattern did
not capture a substring, <code class="code">None</code> is returned in the corresponding
position instead.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">full_match</span>: default = true</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Not_found</span>: if pattern does not match.</li></ul></div></div><div class="spec val" id="val-extract_all"><a href="#val-extract_all" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>extract_all : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;full_match:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> string array array</code></div><div class="doc"><p><code class="code">extract_all ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> an array of arrays of all matching substrings that match
<code class="code">subj</code> starting at position <code class="code">pos</code>, using pattern <code class="code">pat</code> when given,
regular expression <code class="code">rex</code> otherwise. Uses <code class="code">flags</code> when given, the
precompiled <code class="code">iflags</code> otherwise. It includes the full match at index
0 of the extracted string arrays when <code class="code">full_match</code> is <code class="code">true</code>, the
captured substrings only when it is <code class="code">false</code>. Callouts are handled by
<code class="code">callout</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">full_match</span>: default = true</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Not_found</span>: if pattern does not match.</li></ul></div></div><div class="spec val" id="val-extract_all_opt"><a href="#val-extract_all_opt" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>extract_all_opt : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;full_match:bool <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> string option array array</code></div><div class="doc"><p><code class="code">extract_all_opt
      ?iflags ?flags ?rex ?pat ?pos ?full_match ?callout subj</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> an array of arrays of all optional matching substrings that
match <code class="code">subj</code> starting at position <code class="code">pos</code>, using pattern <code class="code">pat</code> when
given, regular expression <code class="code">rex</code> otherwise. Uses <code class="code">flags</code> when given,
the precompiled <code class="code">iflags</code> otherwise. It includes <code class="code">Some full_match_str</code>
at index 0 of the extracted string arrays when <code class="code">full_match</code> is <code class="code">true</code>,
<code class="code">Some captured_substrings</code> only when it is <code class="code">false</code>. Callouts are
handled by <code class="code">callout</code>. If a subpattern did not capture a substring,
<code class="code">None</code> is returned in the corresponding position instead.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">full_match</span>: default = true</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Not_found</span>: if pattern does not match.</li></ul></div></div><div class="spec val" id="val-pmatch"><a href="#val-pmatch" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pmatch : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"><p><code class="code">pmatch ?iflags ?flags ?rex ?pat ?pos ?callout subj</code></p><ul class="at-tag"><li><span class="at-tag return">Returns</span> <code class="code">true</code>
if <code class="code">subj</code> is matched by pattern <code class="code">pat</code> when given, regular expression
<code class="code">rex</code> otherwise, starting at position <code class="code">pos</code>. Uses <code class="code">flags</code> when given,
the precompiled <code class="code">iflags</code> otherwise. Callouts are handled by <code class="code">callout</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li></ul></div></div><div class="h7">String substitution</div><div class="spec type" id="type-substitution"><a href="#type-substitution" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>substitution</code><code></code><code></code></div><div class="doc"><p>Information on substitution patterns</p></div></div><div class="spec val" id="val-subst"><a href="#val-subst" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>subst : string <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-substitution">substitution</a></code></div><div class="doc"><p><code class="code">subst str</code> converts the string <code class="code">str</code> representing a
substitution pattern to the internal representation</p><p>The contents of the substitution string <code class="code">str</code> can be normal text
mixed with any of the following (mostly as in PERL):</p><ul><li><em>$[0-9]+</em> - a &quot;$&quot; immediately followed by an arbitrary number.
&quot;$0&quot; stands for the name of the executable,
any other number for the n-th backreference.</li><li><em>$&amp;</em> - the whole matched pattern</li><li><em>$`</em> - the text before the match</li><li><em>$'</em> - the text after the match</li><li><em>$+</em> - the last group that matched</li><li><em>$$</em> - a single &quot;$&quot;</li><li><em>$!</em> - delimiter which does not appear in the substitution.
Can be used to part &quot;$<code class="code">0-9</code>+&quot; from an immediately
following other number.</li></ul></div></div><div class="spec val" id="val-replace"><a href="#val-replace" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>replace : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;itempl:<a href="index.html#type-substitution">substitution</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;templ:string <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p><code class="code">replace ?iflags ?flags ?rex ?pat ?pos ?itempl ?templ ?callout subj</code>
replaces all substrings of <code class="code">subj</code> matching pattern <code class="code">pat</code> when given,
regular expression <code class="code">rex</code> otherwise, starting at position <code class="code">pos</code> with
the substitution string <code class="code">templ</code> when given, <code class="code">itempl</code> otherwise. Uses
<code class="code">flags</code> when given, the precompiled <code class="code">iflags</code> otherwise. Callouts
are handled by <code class="code">callout</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">itempl</span>: default = empty string</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">templ</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Failure</span>: if there are backreferences to nonexistent subpatterns.</li></ul></div></div><div class="spec val" id="val-qreplace"><a href="#val-qreplace" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>qreplace : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;templ:string <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p><code class="code">qreplace ?iflags ?flags ?rex ?pat ?pos ?templ ?callout subj</code>
replaces all substrings of <code class="code">subj</code> matching pattern <code class="code">pat</code> when given,
regular expression <code class="code">rex</code> otherwise, starting at position <code class="code">pos</code>
with the string <code class="code">templ</code>. Uses <code class="code">flags</code> when given, the precompiled
<code class="code">iflags</code> otherwise. Callouts are handled by <code class="code">callout</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">templ</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li></ul></div></div><div class="spec val" id="val-substitute_substrings"><a href="#val-substitute_substrings" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>substitute_substrings : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> subst:(<a href="index.html#type-substrings">substrings</a> <span class="keyword">&#8209;&gt;</span> string) <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p><code class="code">substitute_substrings ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code>
replaces all substrings of <code class="code">subj</code> matching pattern <code class="code">pat</code> when given,
regular expression <code class="code">rex</code> otherwise, starting at position <code class="code">pos</code>
with the result of function <code class="code">subst</code> applied to the substrings
of the match. Uses <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code>
otherwise. Callouts are handled by <code class="code">callout</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li></ul></div></div><div class="spec val" id="val-substitute"><a href="#val-substitute" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>substitute : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> subst:(string <span class="keyword">&#8209;&gt;</span> string) <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p><code class="code">substitute ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code>
replaces all substrings of <code class="code">subj</code> matching pattern <code class="code">pat</code> when given,
regular expression <code class="code">rex</code> otherwise, starting at position <code class="code">pos</code> with
the result of function <code class="code">subst</code> applied to the match. Uses <code class="code">flags</code>
when given, the precompiled <code class="code">iflags</code> otherwise. Callouts are handled
by <code class="code">callout</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li></ul></div></div><div class="spec val" id="val-replace_first"><a href="#val-replace_first" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>replace_first : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;itempl:<a href="index.html#type-substitution">substitution</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;templ:string <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p><code class="code">replace_first ?iflags ?flags ?rex ?pat ?pos ?itempl ?templ ?callout subj</code>
replaces the first substring of <code class="code">subj</code> matching pattern <code class="code">pat</code> when
given, regular expression <code class="code">rex</code> otherwise, starting at position
<code class="code">pos</code> with the substitution string <code class="code">templ</code> when given, <code class="code">itempl</code>
otherwise. Uses <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code>
otherwise. Callouts are handled by <code class="code">callout</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">itempl</span>: default = empty string</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">templ</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Failure</span>: if there are backreferences to nonexistent subpatterns.</li></ul></div></div><div class="spec val" id="val-qreplace_first"><a href="#val-qreplace_first" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>qreplace_first : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;templ:string <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p><code class="code">qreplace_first ?iflags ?flags ?rex ?pat ?pos ?templ ?callout subj</code>
replaces the first substring of <code class="code">subj</code> matching pattern <code class="code">pat</code> when
given, regular expression <code class="code">rex</code> otherwise, starting at position <code class="code">pos</code>
with the string <code class="code">templ</code>. Uses <code class="code">flags</code> when given, the precompiled
<code class="code">iflags</code> otherwise. Callouts are handled by <code class="code">callout</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">templ</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li></ul></div></div><div class="spec val" id="val-substitute_substrings_first"><a href="#val-substitute_substrings_first" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>substitute_substrings_first : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> subst:(<a href="index.html#type-substrings">substrings</a> <span class="keyword">&#8209;&gt;</span> string) <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p><code class="code">substitute_substrings_first
       ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code>
replaces the first substring of <code class="code">subj</code> matching pattern <code class="code">pat</code> when
given, regular expression <code class="code">rex</code> otherwise, starting at position
<code class="code">pos</code> with the result of function <code class="code">subst</code> applied to the substrings
of the match. Uses <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code>
otherwise. Callouts are handled by <code class="code">callout</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li></ul></div></div><div class="spec val" id="val-substitute_first"><a href="#val-substitute_first" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>substitute_first : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> subst:(string <span class="keyword">&#8209;&gt;</span> string) <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p><code class="code">substitute_first ?iflags ?flags ?rex ?pat ?pos ?callout ~subst subj</code>
replaces the first substring of <code class="code">subj</code> matching pattern <code class="code">pat</code> when
given, regular expression <code class="code">rex</code> otherwise, starting at position
<code class="code">pos</code> with the result of function <code class="code">subst</code> applied to the match. Uses
<code class="code">flags</code> when given, the precompiled <code class="code">iflags</code> otherwise. Callouts
are handled by <code class="code">callout</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li></ul></div></div><div class="h7">Splitting</div><div class="spec val" id="val-split"><a href="#val-split" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>split : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;max:int <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> string list</code></div><div class="doc"><p><code class="code">split ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> splits <code class="code">subj</code>
into a list of at most <code class="code">max</code> strings, using as delimiter pattern
<code class="code">pat</code> when given, regular expression <code class="code">rex</code> otherwise, starting at
position <code class="code">pos</code>. Uses <code class="code">flags</code> when given, the precompiled <code class="code">iflags</code>
otherwise. If <code class="code">max</code> is zero, trailing empty fields are stripped. If
it is negative, it is treated as arbitrarily large. If neither <code class="code">pat</code>
nor <code class="code">rex</code> are specified, leading whitespace will be stripped! Should
behave exactly as in PERL. Callouts are handled by <code class="code">callout</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">max</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li></ul></div></div><div class="spec val" id="val-asplit"><a href="#val-asplit" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>asplit : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;max:int <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> string array</code></div><div class="doc"><p><code class="code">asplit ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> same as
<a href="index.html#val-split">Pcre.split</a> but</p><ul class="at-tag"><li><span class="at-tag return">Returns</span> an array instead of a list.</li></ul></div></div><div class="spec type" id="type-split_result"><a href="#type-split_result" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>split_result</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-split_result.Text" class="anchored"><td class="def constructor"><a href="#type-split_result.Text" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Text</span><span class="keyword"> of </span>string</code></td><td class="doc"><p>(** Text part of split string *)</p></td></tr><tr id="type-split_result.Delim" class="anchored"><td class="def constructor"><a href="#type-split_result.Delim" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Delim</span><span class="keyword"> of </span>string</code></td><td class="doc"><p>(** Delimiter part of split string *)</p></td></tr><tr id="type-split_result.Group" class="anchored"><td class="def constructor"><a href="#type-split_result.Group" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Group</span><span class="keyword"> of </span>int<span class="keyword"> * </span>string</code></td><td class="doc"><p>(** Subgroup of matched delimiter
(subgroup_nr, subgroup_str) *)</p></td></tr><tr id="type-split_result.NoGroup" class="anchored"><td class="def constructor"><a href="#type-split_result.NoGroup" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">NoGroup</span></code></td><td class="doc"><p>(** Unmatched subgroup *)</p></td></tr></table><code></code></div><div class="doc"><p>Result of a <a href="index.html#val-full_split">Pcre.full_split</a></p></div></div><div class="spec val" id="val-full_split"><a href="#val-full_split" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>full_split : ?&#8288;iflags:<a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;flags:<a href="index.html#type-rflag">rflag</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;rex:<a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;pat:string <span class="keyword">&#8209;&gt;</span> ?&#8288;pos:int <span class="keyword">&#8209;&gt;</span> ?&#8288;max:int <span class="keyword">&#8209;&gt;</span> ?&#8288;callout:<a href="index.html#type-callout">callout</a> <span class="keyword">&#8209;&gt;</span> string <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-split_result">split_result</a> list</code></div><div class="doc"><p><code class="code">full_split ?iflags ?flags ?rex ?pat ?pos ?max ?callout subj</code> splits
<code class="code">subj</code> into a list of at most <code class="code">max</code> elements of type &quot;split_result&quot;,
using as delimiter pattern <code class="code">pat</code> when given, regular expression
<code class="code">rex</code> otherwise, starting at position <code class="code">pos</code>. Uses <code class="code">flags</code> when given,
the precompiled <code class="code">iflags</code> otherwise. If <code class="code">max</code> is zero, trailing empty
fields are stripped. If it is negative, it is treated as arbitrarily
large. Should behave exactly as in PERL. Callouts are handled by
<code class="code">callout</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">iflags</span>: default = no extra flags</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">flags</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rex</span>: default = matches whitespace</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pat</span>: default = ignored</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">pos</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">max</span>: default = 0</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">callout</span>: default = ignore callouts</li></ul></div></div><div class="h7">Additional convenience functions</div><div class="spec val" id="val-foreach_line"><a href="#val-foreach_line" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>foreach_line : ?&#8288;ic:Pervasives.in_channel <span class="keyword">&#8209;&gt;</span> (string <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">foreach_line ?ic f</code> applies <code class="code">f</code> to each line in inchannel <code class="code">ic</code> until
the end-of-file is reached.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">ic</span>: default = stdin</li></ul></div></div><div class="spec val" id="val-foreach_file"><a href="#val-foreach_file" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>foreach_file : string list <span class="keyword">&#8209;&gt;</span> (string <span class="keyword">&#8209;&gt;</span> Pervasives.in_channel <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">foreach_file filenames f</code> opens each file in the list <code class="code">filenames</code>
for input and applies <code class="code">f</code> to each filename and the corresponding
channel. Channels are closed after each operation (even when
exceptions occur - they get reraised afterwards!).</p></div></div><div class="h7"><b>UNSAFE STUFF - USE WITH CAUTION!</b></div><div class="spec val" id="val-unsafe_pcre_exec"><a href="#val-unsafe_pcre_exec" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>unsafe_pcre_exec : <a href="index.html#type-irflag">irflag</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> pos:int <span class="keyword">&#8209;&gt;</span> subj_start:int <span class="keyword">&#8209;&gt;</span> subj:string <span class="keyword">&#8209;&gt;</span> int array <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-callout">callout</a> option <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">unsafe_pcre_exec flags rex ~pos ~subj_start ~subj offset_vector</code>.
You should read the C-source to know what happens.
If you do not understand it - <b>don't use this function!</b></p></div></div><div class="spec val" id="val-make_ovector"><a href="#val-make_ovector" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>make_ovector : <a href="index.html#type-regexp">regexp</a> <span class="keyword">&#8209;&gt;</span> int<span class="keyword"> * </span>int array</code></div><div class="doc"><p><code class="code">make_ovector regexp</code> calculates the tuple (subgroups2, ovector)
which is the number of subgroup offsets and the offset array.</p></div></div></body></html>